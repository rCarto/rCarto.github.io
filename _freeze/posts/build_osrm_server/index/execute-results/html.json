{
  "hash": "d88af341efca0226979617bc593c40df",
  "result": {
    "markdown": "---\ntitle: \"How to Build a European-Wide OSRM Server on a Desktop Computer\"\nauthor: \"Timoth√©e Giraud\"\ndate: \"2023-10-09\"\ncategories: [osrm]\nimage: \"cob.png\"\ndraft: false\nbibliography: references.bib\n---\n\n\n[Open Source Routing Machine](https://github.com/Project-OSRM/osrm-backend), or OSRM [@luxen-vetter-2011], is a routing software based on OpenStreetMap (OSM) data. OSRM can be used to find the fastest route between points, to compute time or distance matrices between set of points or to solve the [traveling salesman problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem).\n\n\nAs maintainer of the `osrm` R package [@giraud2022] I often find myself advising users to use their own instance of OSRM to enable them to send a large number of requests and not overload the demo server. In these cases I simply point to the Docker installation instructions in the project's [README](https://github.com/Project-OSRM/osrm-backend#using-docker) file. These instructions may not be detailed enough to build an OSRM instance on a large area.   \nOSRM needs **a lot** of RAM to prepare the road network for requests and using only these instructions will probably result in message like this one:  \n```sh \n[warn] Please provide more memory or consider using a larger swapfile\n```\nThis problem is addressed in [this issue](https://github.com/Project-OSRM/osrm-backend/issues/6146) on the OSRM GitHub repository. The suggested solution is to rent a temporary server. This is not the only solution, a modern computer with a rather classical hardware configuration can actually do the job. \n\nIn this post I'll explain how to build a European-wide OSRM instance on a desktop computer. These explanations are, to a certain extent, also valid when using a remote server. \n\n\n::: {.callout-note}\nThis post implies some Linux/CLI/Docker knowledge from its reader. \n:::\n\n\n\n## Hardware\n\nI use my personal laptop computer which has a 1 TB SSD hard drive and the following config:\n\n<pre><span style=\"color:#C01C28\"><b>OS</b></span>: Debian GNU/Linux 12 (bookworm) x86_64 \n<span style=\"color:#C01C28\"><b>Host</b></span>: HP EliteBook 840 G8 Notebook PC \n<span style=\"color:#C01C28\"><b>Kernel</b></span>: 6.1.0-10-amd64 \n<span style=\"color:#C01C28\"><b>CPU</b></span>: 11th Gen Intel i7-1185G7 (8) @ 4.800GHz \n<span style=\"color:#C01C28\"><b>Memory</b></span>: 31.04GB </pre>\n\n## Add some extra memory\n\nThe preparation of the OSM network for OSRM is memory intensive and will need more than the already available 32 GB of RAM. The [swap memory](https://en.wikipedia.org/wiki/Memory_paging) is used when a program consume the totality of the available RAM memory. Consequently we need to [extend the swap memory](https://github.com/Project-OSRM/osrm-backend/wiki/Running-OSRM#extracting-the-road-network-osrm-extract) of our computer. I use a very large file (a 200 GB file named \"swap.swap\") to be sure to not exceed the limit.  \n\n```sh\n# preallocate space to a file named swap.swap\nsudo fallocate -l 200G swap.swap\n# change file access permissions\nsudo chmod 600 swap.swap\n# set the file as a swap area\nsudo mkswap swap.swap\n# start swapping to the file\nsudo swapon swap.swap\n# modify the swapiness\nsudo sysctl vm.swappiness=20\n```\n\n## Download the OSM road network\n\nThe [Geofabrik website](https://www.geofabrik.de/) provides [OSM database extracts](https://download.geofabrik.de/) that can be used as input for OSRM. \nIn our case we have downloaded the **osm.pbf** file for Europe (27.1 GB).\n\n## Build the dataset for OSRM\n\nThe **europe-latest.osm.pbf** file needs to be processed to be used by OSRM. This is done in three steps. You can change the transport mode in the first step, here we use the car profile. \n\n1. Extract (~5h30)\n```sh\ndocker run -t -v \"${PWD}:/data\" ghcr.io/project-osrm/osrm-backend:v5.27.1 osrm-extract -p /opt/car.lua /data/europe-latest.osm.pbf\n```\n\n2. Partition (~1h20)\n```sh\ndocker run -t -v \"${PWD}:/data\" ghcr.io/project-osrm/osrm-backend:v5.27.1 osrm-partition /data/europe-latest.osrm\n```\n\n3. Customize (~0h10)\n```sh\ndocker run -t -v \"${PWD}:/data\" ghcr.io/project-osrm/osrm-backend:v5.27.1 osrm-customize /data/europe-latest.osrm\n```\n\n\n## Run the instance\n\nThis is the command I use to run this freshly built OSRM instance:\n\n```sh\ndocker run --rm -t -i -p 5000:5000 -v \"${PWD}:/data\" ghcr.io/project-osrm/osrm-backend:v5.27.1 osrm-routed --algorithm mld --max-table-size 50000000 /data/europe-latest.osrm\n```\n\n\n\n\n## Another experiment\n\nI've conducted the same operation on a laptop with lower capacities: \n\n<pre><span style=\"color:#C01C28\"><b>OS</b></span>: Debian GNU/Linux 12 (bookworm) x86_64 \n<span style=\"color:#C01C28\"><b>Host</b></span>: HP EliteBook Folio 1040 G3 \n<span style=\"color:#C01C28\"><b>Kernel</b></span>: 6.1.0-12-amd64 \n<span style=\"color:#C01C28\"><b>CPU</b></span>: Intel i7-6600U (4) @ 3.400GHz \n<span style=\"color:#C01C28\"><b>Memory</b></span>: 15.50GB </pre>\n\nThe dataset build for OSRM took much longer but was ultimately successful:\n\n1. Extract ~56h \n2. Partition ~2h40\n3. Customize ~1h\n\n\n\n\n\n\n\n## Example of use\n\nThis OSRM instance will actually be used in the framework of a European research program ([Granular](https://www.ruralgranular.eu/)). In this project we'll need to request a very large number of distances and routes throughout Europe in order to create relevant accessibility indicators for rural areas.  \nI've built a small R package relying on `osrm` to send queries in a parallel fashion and create \"All roads lead to...\" maps. The [`cobweb` package](https://github.com/rcarto/cobweb) is not bulletproof and it is not on CRAN.  \n\nHere is a small demo:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"rCarto/cobweb\")\nlibrary(cobweb)\ncobweb(city = \"Mainz, Germany\", \n       nroad = 3000, ncl = 8, \n       url = \"http://0.0.0.0:5000/\")\n```\n:::\n\n\n![All Roads Lead to Mainz!](map.png)\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}